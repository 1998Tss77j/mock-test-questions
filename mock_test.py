# -*- coding: utf-8 -*-
"""mock test

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mbRcC_mRWCj0Eo7v-I9Cfd15tNb1mtTz

Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator.

 Example 1:
Input: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2.
Example 2:

Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
Constraints:

0 <= x <= 2^31 - 1
"""

def floorSqrt(x):

    # Base cases
    if (x == 0 or x == 1):
        return x

    # Starting from 1, try all numbers until
    # i*i is greater than or equal to x.
    i = 1
    result = 1
    while (result <= x):

        i += 1
        result = i * i

    return i - 1


# Driver Code
x = 4
print(floorSqrt(x))

def floorSqrt(x):

    # Base cases
    if (x == 0 or x == 1):
        return x

    # Starting from 1, try all numbers until
    # i*i is greater than or equal to x.
    i = 1
    result = 1
    while (result <= x):

        i += 1
        result = i * i

    return i - 1


# Driver Code
x = 8
print(floorSqrt(x))

"""You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.


Example 1:

Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0] Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1]




"""

class Solution:
    # Function to reverse a list
    def reverse(self, head):
        if head is None or head.next is None:
            return head
        prev = None
        next = None
        curr = head
        while curr is not None:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        head = prev
        return head

    # Function to add two numbers represented by linked list.

    def addTwoLists(self, first, second):

        # reverse the two lists
        curr1 = self.reverse(first)
        curr2 = self.reverse(second)

        # res is head node of the resultant list
        sum = 0
        carry = 0
        res = None
        prev = None

        # while both lists have atleast one node
        while curr1 is not None or curr2 is not None:

            # Calculating the sum of the last digits
            sum = carry + (curr1.data if curr1 else 0) + \
                (curr2.data if curr2 else 0)

            # update carry for next calculation
            carry = (1 if sum >= 10 else 0)

            # update sum if it is greater than 10
            sum = sum % 10

            # Create a new node with sum as data
            temp = Node(sum)

            # if this is the first node then set it as head of the resultant list
            if res is None:
                res = temp

            # If this is not the first node then connect it to the rest.
            else:
                prev.next = temp

            # Set prev for next insertion
            prev = temp

            # Move first and second pointers to next nodes
            if curr1:
                curr1 = curr1.next
            if curr2:
                curr2 = curr2.next

        # if carry from previous sums is remaining
        if carry > 0:
            temp.next = Node(carry)

        # Reverse the resultant answer
        ans = self.reverse(res)
        return ans


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next

# Utility function to print the list


def printList(n):
    while n:
        print(n.data, end = ' ')
        n = n.next
    print()


# Driver Code
if __name__ == "__main__":

    arr1 = [2,4,3,5,6,4]
    LL1 = LinkedList()
    for i in arr1:
        LL1.insert(i)
    print("First list is", end = " ")
    printList(LL1.head)

    arr2 = [0,0]
    LL2 = LinkedList()
    for i in arr2:
        LL2.insert(i)
    print("Second list is", end = " ")
    printList(LL2.head)

    # Function Call
    res = Solution().addTwoLists(LL1.head, LL2.head)
    print("Resultant list is", end = " ")
    printList(res)